---
layout: post
title:  "React 정리 #2"
subtitle:   ""
date: 2019-08-02 14:12:01
categories: devlog
tags: bit
---

## #1

---

```javascript
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    return (
      <div>
        <Bpp a = '호랑이' b = '10' c = {30}/>
      </div>
    )
  }
}

class Bpp extends Component {
  render() {
    console.log(this.props.c);
    //* props는 데이터를 갱신할 수 없다 (부모가 변경시킬 수는 있지만, 자식이 직접 갱신 시킬 수는 없다. (자체적으로 갱신 불가))
    // this.props.c = 50

    return (
      <div>
        <h1>{this.props.a}</h1>
        <h1>{this.props.b}</h1>
        <h1>{this.props.c}</h1>
      </div>
    )
  }
}
```

---

<br/>
### #2

---

- `&&` 사용

**(ex)**
create-react-app test01 `&&` cd test01 `&&` npm start

---
<br/>
## 프로젝트 생성 팁

---

- `set '변수이름' = '데이터'`

  해당 문구 사용시 `%%`로 변수 참조 가능.
  **(ex)**
  set projectname = test02  
       create-react-app `%projectname%`

- 프로젝트 생성 복사용
    ```bash
    set projectname=test02
    create-react-app %projectname% && cd %projectname% && npm start
    ```

---

<br/>
### React 프로젝트 생성

---

- `rcc` 입력 엔터 -> java의 main과 같음

1. git hub에서 소스 파일 받아올 때, 안에 node_module이 없음. 
  (java 프로젝트에서 JDK가 없는것과 동일)
2. 해당 소스코드를 실행해 주기 위하여 프로젝트 내로 들어가 `npm install`을 터미널에서 실행하여, 설치한다.
3. 이후 `npm start`를 적어주어 실행

---

<br/>
### npm start 방식

---

1. CMD에서 `npm start` 입력
2. VSCode 터미널에서 `npm start` 입력

- VSCode에서 `npm start` 할 경우에는, VSCode의 디버깅란이 사용 불가가 된다.
  (그래서 본인은 CMD로 사용할 것)

---

<br/>
### div, fragment 차이점

---

- `<div>`사용시 
  개발자 모드에서 `<div>`가 더럽게 중첩되어 많이 보이는 현상이 발생 (여러개의 div 사용시)

- `<fragment>` 사용시
  개발자 모드에서 `<div>` 보이지 않음.
  → 대신 어디에 코드가 속해있는지 볼 수 없어 난잡해 보이기도 함

---

<br/>
### 실습 #1

---

- 외부파일 import 시 `import ''` 사용
- JavaScript 코드 영역과 JSX 문법 영역이 있다.
- html에서는 단일 태그에서 `/`생략이 가능하나, JSX에서는  `/` 생략 불가
- **메인태그(`<div>` 등) 존재必**

```javascript
import React, { Component } from 'react'
// import 구문을 적어 외부 파일을 import
import './App.css'

export default class App extends Component {
  render() {
    // JavaScript 코드 영역
    console.log('적당한 문자열');
    const s = '문자열'
    const b = false
    // JSX 문법 영역 -> 여기가 <body> 구문이라고 보면 됨.
    // html + javascript의 코드 작성 가능
    return (
      // 반드시 return() 내에 메인태그가 무조건 한개이상은 존재해야함
      // html에서는 단일태그(<div/>)의 '/' 생략가능하지만, react에서는 생략 불가
      <div>
        <h1>{s}</h1>
        {
          // JSX : if else 문은 사용불가능하지만 삼항연산은 가능
          b ? '호랑이' : '코끼리'
        }
        <div className='st'>
          <h1>안녕</h1>
        </div>

        <h1>적당한 글자</h1> <br/>
        {/* 주석은 이렇게 잡는다 */}
        {/* <h1>적당한 글자</h1> */}
      </div>
    )
  }
}
```

---

<br/>
### 실습 #2

---

- **함수 만드는 방법 세가지**
  1. `f1() {}`
  2. `f2 = function () {}`
  3. `f3 = () => {}`

- `render()` 본문에서 메소드 사용법
  → `javascript`를 사용하려면 `{}` 내에 명시  

```javascript
import React, { Component } from 'react'

export default class App extends Component {
  //함수 만드는 방법 세가지
  // 1
  // 앞에 function 붙이면 사용 X
  f1() { console.log('1'); }
  // 2
  f2 = function() { console.log('2'); }
  // 3
  f3 = () => { console.log('3'); }

  render() {
    return (
      <div>
        <button onClick={this.f1}>버튼1</button>
        <button onClick={this.f2}>버튼2</button>
        <button onClick={this.f3}>버튼3</button>
      </div>
    )
  }
}

```

---

<br/>
### 실습 #3

---

- 컴포넌트 추가 방법
- 컴포넌트 불러오는 방식 : 단독 태그로 사용(**(ex)** `<Component1 />`)
- export default는 하나의 파일에 반드시 한개 존재해야하며, Only 한개만 존재해야 한다.

```javascript
import React, { Component } from 'react'

//export default는 하나의 파일에 하나만 존재 & 반드시 존재
export default class App extends Component {

  render() {
    return (
      <div>
        호랑이
        {/* - 단독 태그로 사용 */}
        <Bpp/>
      </div>
    )
  }
}

// Component는 단독 태그처럼 사용할 수 있다.
class Bpp extends Component {

  render() {
    return (
      <div>
        독수리
      </div>
    )
  }
}
```

<br/>
### 실습 #3

---

- 외부 js 파일을 import한 후, 태그로 불러 올 수 있다.

```javascript
import React, { Component } from 'react'
// import 예제
import Bpp from './bpp'
import Cpp from './cpp'

export default class App extends Component {

  render() {
    return (
      <div>
        호랑이
        {/* - 단독 태그로 사용 */}
        <Bpp/>
        <Cpp/>
      </div>
    )
  }
}
```

---

<br/>
### 실습 #4

---

- 다른 js로 

```javascript
// 하나의 파일에서 export default가 아닌 나머지 클래스는 'OOO, {...}' 라고 사용한다.
//React js에 여러개의 Class를 사용할 땐 {}를 사용.
import React, { Component, Fragment } from 'react';
// 외부 css 파일 import
import './App.css';
// 외부 js 파일 import
import Cpp from './Apple/cpp';

export default class App extends Component {

  render() {
    
    return (
      <div>
        <Fragment>
          // Bpp에 인수 전달
          <Bpp name='호랑이' age={27}></Bpp>
          <Cpp></Cpp>
        </Fragment>
      </div>
    );
  }
}

class Bpp extends Component {

  render() {

    return (
      <div>
        <Fragment>
          <h1>
            {this.props.name}
            {this.props.age}
            {console.log(typeof this.props.age)}
          </h1>
          고양이는 멍멍
        </Fragment>
      </div>
    );
  }
}
```

---

<br/>
### 실습 #5

---

- **Props와 State의 차이점**
  - Props
    - 값을 단순히 받아오고, 값 갱신이 불가능.
  - State 
    - 컴포넌트 자체에서 초기화 하며, 값 갱신이 가능하다.
      - 값 갱신시 `setState()` 사용.

- **꼭 State를 사용해야 하는 이유가 있는가?**
  - 일반 필드명으로도 선언이 가능하고, 값도 갱신이 가능하다. 하지만...
  - `setState`로 값을 갱신시 render()함수가 호출되어 화면상에 값 갱신이 실시간으로 가능하다. 하지만 `일반 필드명`으로 값을 갱신시, render()함수를 가지고 오지 않아, 화면상의 값 갱신이 실시간으로 되지 않는다.

- **정리**
  1. 컨트롤 안에 값이 갱신되는 함수(화면에 보여야 하는 데이터)는 모두 state를 사용하자
  2. 화면에 보이는것과 관계없이 컴포넌트와 관계없이 내부적으로만 사용하는 변수는 필드로 사용해도 무방

```javascript
import React, { Component } from 'react'

export default class App extends Component {
  // 함수가 들어가는 영역
  // state는 값 갱신이 가능
  state = {
    // 객체 문법
    n1: 0,
  }

  // 일반 필드명도 선언 가능
  n2 = 0

  f1 = () => {
    // state는 형식을 갖춰 갱신을 시켜주어야 한다.
    // 단독으로 변경이 불가하고 setState를 사용해야한다.

    //setState를 사용한것과 일반 필드로 사용한것들은 차이가 있다.
    //setState를 사용하면 함수를 매번 실행하는것 처럼 즉각적으로 렌더링 하여 실시간으로 값을 변경시켜 보여주나, 필드로 사용하면 즉각적으로 렌더링이 되지 않고, 함수 내의 '값'만 변경된다.

    // 차이점 : 값을 갱신할수 있다 없다로 구분
    // props는 값을 단순히 받아오는 것, state는 컴포넌트 자체에서 초기화 한다.
    //state는 set state라는 함수를 이용하여 값을 갱신시켜야한다. 갱신시키는 구조는 객체형식을 따름
    // 렌더 함수를 콜 하느냐 안하느냐로 구분된다.

    // 컨트롤 안에 값이 갱신되는 함수(화면에 보여야 하는 데이터)는 모두 state 함수, 그러나 화면에 보이는것과 관계없이 컴포넌트와 관계없이 내부적으로만 사용하는 변수는 그냥 선언

    this.setState({
      n1 : this.state.n1 + 1
    });

  }

  f2 = () => {
    this.n2++
  }

  render() {
    // JAVA 코드가 들어가는 영역
    console.log(this.state.n1);
    console.log(this.n2);
    return (
      // JSX 들어가는 영역
      <div>
        <h1>{this.state.n1}</h1>
        <h1>{this.n2}</h1>
        <button onClick={this.f1}>클릭1</button>
        <button onClick={this.f2}>클릭2</button>
      </div>
    )
  }
}
```

---

<br/>
### 정리

---

---