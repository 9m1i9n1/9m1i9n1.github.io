---
layout: post
title:  "테스트 주도 개발(TDD) - 개발툴편"
subtitle:   ""
date: 2019-09-04 08:30:44
categories: devlog
tags: web bit
---

[react-testing-library 를 사용한 리액트 컴포넌트 테스트](https://velog.io/@velopert/react-testing-library)
[react-testing-library를 사용하여 TDD 개발 흐름으로 투두리스트 만들기](https://velog.io/@velopert/tdd-with-react-testing-library)

TDD 개발 툴에 대한 정리 글이다.
해당 툴에 대한 간단한 설명 및 사용하는 함수들을 정리한다.

- - -

<br/>
### JEST

- - -

- 페이스북 팀에서 Jasmine 기반으로 만든 테스팅 프레임 워크이다. C-R-A로 만든 리액트 프로젝트에는 자동으로 적용이 되어있다.

- - -

### react-testing-library

- Enzyme과 달리 모든 테스트를 DOM 위주로 진행하며, 컴포넌트의 props나 state를 조회하는 일은 없다.
  (컴포넌트를 리팩토링 하게 될 때에는 주로 내부 구조 및 네이밍은 많이 바뀔 수 있어도 실제 작동 방식은 크게 바뀌지 않는다. 이점을 중요시 여겨 컴포넌트의 기능이 똑같이 작동한다면 컴포넌트의 내부 구현 방식이 많이 바뀌어도 테스트가 실패하지 않도록 설계)

- **즉, react-testing-library는 구현 (Enzyme)에 중점을 둔 테스트보다는 사용자 행동 (react-testing-library)에 중점을 둔다.**

- 2019.09.04일 기준 라이브러리가 바뀌었다. 아래의 명령어로 설치.
    ```
    yarn add @testing-library/react @testing-library/jest-dom @types/jest
    ```
- `setupTests.js`의 내용을 아래의 코드로 변경
    ```
    import "@testing-library/react";
    import "@testing-library/jest-dom/extend-expect";
    ```

- 해당 `render`에 의구심이 있었는데, 보니까 벨로퍼트의 글에 잘 나와있더라.
   > react-testing-library 에서는 리액트에서는 DOM 시뮬레이션을 위한 [JSDOM](https://github.com/jsdom/jsdom) 이라는 도구를 사용하여 document.body 에 리액트 컴포넌트를 렌더링합니다. clean-up-after-each 를 불러오면, 각 테스트 케이스가 끝날때마다 기존에 가상의 화면에 남아있는 UI 를 정리합니다.

추가적으로, 그 아래에는 jest-dom/extend-expect 를 불러와서 jest 에서 DOM 관련 matcher 를 사용 할 수 있게 해주었습니다.

---

#### 사용하는 함수

`it`
- 새로운 테스트 케이스를 만드는 함수이다. 

`expect`
- it 내부에서 해당 함수를 통하여 특정 값이 우리가 예상한 값이 나왔는지 확인 할 수 있다.

`describe`
- 여러개의 `it`을 넣기 위함이다. `describe`안에는 또 여러개의 `describe`를 넣을 수 있다.

`render`
- 이 함수가 호출되면 그 결과물에는 DOM을 선택 할 수 있는 다양한 쿼리들과 `container`가 포함되어 있다. 여기서 `container`는 해당 컴포넌트의 최상위 `DOM`을 가르키며, 이를 가지고 스냅샷 테스팅을 할 수 도 있다.

---

#### 사용하는 쿼리 함수
###### Variant

`getBy*`
- 조건에 일치하는 DOM 엘리먼트 하나를 선택. 존재하지 않으면 에러.

`getAllBy*`
- 조건에 일치하는 DOM 엘리먼트 여러개를 선택. 존재하지 않으면 에러.

`queryBy*`
- 조건에 일치하는 DOM 엘리먼트 하나를 선택. 존재하지 않아도 에러 X.
  
`queryAllBy*`
- 조건에 일치하는 DOM 엘리먼트 여러개를 선택. 존재하지 않아도 에러 X.

`findBy*`
- 조건에 일치하는 DOM 엘리먼트 하나가 나타날 때까지 기다렸다가 해당 `DOM`을 선택하는 `Promise` 반환. (기본 Timeout 조건인 4500ms 이후에도 나타나지 않으면 에러 발생)

`findAllBy*`
- 조건에 일치하는 DOM 엘리먼트 여러개가 나타날 때까지 기다렸다가 해당 `DOM`을 선택하는 `Promise` 반환. (기본 Timeout 조건인 4500ms 이후에도 나타나지 않으면 에러 발생)


###### Queries

`ByLabelText`
- label이 있는 input의 label 내용으로 input 선택.
    ```javascript
    <label for="username-input">아이디</label>
    <input id="username-input" />

    const inputNode = getByLabelText('아이디');
    ```

`ByPlaceholderText`
- placeholder 값으로 input 및 textarea를 선택.
    ```javascript
    <input placeholder="아이디" />;

    const inputNode = getByPlaceholderText('아이디');
    ```

`ByText`
- 엘리먼트가 가지고 있는 텍스트 값으로 DOM 선택
    ```javascript
    <div>Hello World!</div>;

    const div = getByText('Hello World!');
    ```

- 참고로 텍스트 값에 정규식을 넣어도 작동한다.
    ```javascript
    const div = getByText(/^Hello/);
    ```

`ByAltText`
- `alt` 속성을 가지고 있는 엘리먼트(주로 `img`)를 선택.
    ```javascript
    <img src="/awesome.png" alt="awesome image" />;
    const imgAwesome = getByAltText('awesome image');
    ```

`ByTitle`
- `title` 속성을 가지고 있는 DOM 혹은 `title` 엘리먼트를 지니고 있는 SVG를 선택할 때 사용.
  > title 속성은 html에서 툴팁을 보여줘야 하는 상황에 사용하곤 한다.

    ```javascript
    <p>
    <span title = "React">리액트</span>는 짱 멋진 라이브러리다.
    </p>

    <svg>
        <title>Delete</title>
        <g><path /></g>
    </svg>

    const spanReact = getByTitle('React');
    const svgDelete = getByTitle('Delete');
    ```

`ByDisplayValue`
- `input`, `textarea`, `select`가 지니고 있는 현재 값을 가지고 엘리먼트를 선택
    ```javascript
    <input value = "text" />
    const input = getByDisplayValue('text');
    ```

`ByRole`
- 특정 `role`값을 지니고 있는 엘리먼트를 선택.
    ```javascript
    <span role = "button">삭제</span>;

    const spanRemove = getByRole('button');
    ```

- **`role`이란?**
    - `WAI-ARIA`와 관련이 생기는데, 그전에 `RIA`의 개념을 잡고 가야한다.  
        (참고한 웹사이트 : [WAI_ARIA](https://www.biew.co.kr/36))

    ---

    - **`RIA(Rich Internet Applications)`란?**
        - 정적인 HTML과 단순한 자바스크립트 환경의 웹이 아닌 동적인 자바스크립트와 Ajax와 같은 기술을 사용한 환경에서 수준 높은 UX(**U**ser e**X**perience)를 제공하는 웹 어플리케이션
        - **[단점]**
          - 화려하고 편리한 웹 애플리케이션이지만 스크린 리더와 같은 보조 기술을 사용하는 장애인들이 접근하기에 취약.
          - 자바 스크립트, AJAX 등을 활용하여 의미를 가지지 않는 요소(\<div>, \<span>)로 특정 컴포넌트를 구현할 때 스크린 리더 등 보조기기에서 해당 컴포넌트의 기능을 명확하게 파악하기 어려움.
          - 주식 시세나 RSS Feed 등 정보가 자동으로 업데이트 되는 경우 스크린리더 등 보조기기에서 업데이트 된 정보를 파악하기 어려움.

    - 때문에 `WAI-ARIA`는 `RIA`에서 스크린 리더 및 보조기기 등에서 접근성 및 상호 운용성을 향사시키기 위한 목적으로 탄생 했으며, 웹 어플리케이션에 역할(Role), 속성(Property), 상태(State) 정보를 추가하여 이를 개선할 수 있도록 제공.

    ---

    - 결국 `role`이란 유저 인터페이스(UI)에 포함된 특정 컴포넌트의 역할을 정의한다.
        (Abstract Roles, Widget Roles, Document Structure Roles, Landmark Roles로 분류)

    - **[예시]**
      - 탭 목록(tablist)과 본문(tabpanel)이 따로 나뉘어져 있는 마크업 구조는 스크린 리더 등 보조기기를 사용하는 사용자에게는 정보 접근이 어려울 수 있다. 이때 Tab 관련 Widget Role을 사용하면 보조기기를 사용하는 사용자에게 보다 정확한 정보를 제공할 수 있다.
        ![탭메뉴 UI구조](https://t1.daumcdn.net/cfile/tistory/992852365B727A0124)

        ```html
        <!--tablist를 사용한 탭메뉴 예시 -->
        <div class="tab_wrap">
            <!-- 탭메뉴 -->
            <!-- role="tablist"을 사용하여 탭메뉴 역할 부여 -->
            <ul role="tablist" class="list_tab">
                <!-- 
                    1. role="tab"을 사용하여 탭메뉴의 탭요소 역할 부여
                    2. aria-controls="{ID}"를 사용하여 해당 탭의 본문과 연결
                    3. aria-seleceted="{boolen}"를 사용하여 해당 탭이 선택유무 명시
                    4. 초점을 받지 못하는 li요소에 tabindex="0"을 사용하여 초점을 받게함
                -->
                <li role="tab" tabindex="0" aria-selected="ture" aria-controls="section1" id="tab1">
                    탭메뉴1
                </li>
                <li role="tab" tabindex="0" aria-selected="false" aria-controls="section2" id="tab2">
                    탭메뉴2
                </li>
                <li role="tab" tabindex="0" aria-selected="false" aria-controls="section3" id="tab3">
                    탭메뉴3
                </li>
            </ul>
        
            <!-- 탭메뉴 본문 -->
            <div class="tab_content">
                <!--
                    1. role="tabpanel"을 사용하여 탭메뉴의 본문 역할 부여
                    2. aria-labelledby="{ID}을 사용하여 탭메뉴와 본문 연결"
                -->
                <section role="tabpanel" id="section1" aria-labelledby="tab1">
                    탭메뉴1의 본문
                </section>
                <section role="tabpanel" id="section2" aria-labelledby="tab2">
                    탭메뉴2의 본문
                </section>
                <section role="tabpanel" id="section3" aria-labelledby="tab3">
                    탭메뉴3의 본문
                </section>                              
            </div>
        </div>
        ```

`ByTextId`
- 다른 방식으로 해당 엘리먼트를 선택하지 못할때 사용하는 방식. 특정 DOM에 직접 test할때 사용할 id를 달아서 선택하는 것을 의미.
    ```JSX
    <div data-testid = "commondiv">흔한 div</div>;

    const commonDiv = getByTestId('commondiv');
    ```

    - **주의할 점**
      - 값을 설정할 때 `data-testid = "..."`의 포맷으로만 설정해야 한다. 추가적으로 `ByTestId`는 다른 방법으로 선택할 수 없을 때에만 사용하자!
      - DOM의 `querySelector`를 사용할 수도 있으나, 이는 지양해야 한다. 차라리 `data-testid`를 설정하는 것이 좋다.

- **어떤 쿼리를 사용해야하지?**
  - 위에 적어놓은 순서가 사용 우선 순위 순서이다.

###### Event

`fireEvent()`
- 해당 함수는 이벤트를 발생시켜 준다.

- **[사용법]**
    ```
    fireEvent.이벤트이름(DOM, 이벤트객체);
    ```
    - 클릭 이벤트의 경우엔 이벤트 객체를 따로 넣어주지 않아도 되지만, change 이벤트 경우엔 다음과 같이 해주어야 한다.
        ```
        fireEvent.change(myInput, { target: { value: 'hello world' } });
        ```